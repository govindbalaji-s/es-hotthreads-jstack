import argparse
import sys
from antlr4 import *

from antlrgen.HotThreadsLexer import HotThreadsLexer
from antlrgen.HotThreadsParser import HotThreadsParser
from antlrgen.JStackDumpLexer import JStackDumpLexer
from antlrgen.JStackDumpParser import JStackDumpParser


# Returns the length(smallest index that returns null) of the list generated by callable context_list
def context_list_length(context_list):
    length = 0
    while context_list(length) is not None:
        length += 1
    return length


class HotThreadsJStack:

    def __init__(self, hot_threads_output_files, jstack, top_stacks, min_cpu):
        self._hot_threads_output_files = hot_threads_output_files
        self._jstack = jstack
        self.top_stacks = top_stacks
        self.min_cpu = min_cpu
        # List of thread names returned by hot threads API
        self._hot_thread_names = []
        # Header info with % of CPU use from hot threads API
        self._hot_thread_headers = {}
        # Thread's dump from jstack
        self._threads_stack = {}

        self._parse_hot_threads()
        self._parse_jstack_dump()

    def _parse_hot_threads(self):
        for file_name in self._hot_threads_output_files:
            input_stream = FileStream(file_name)
            lexer = HotThreadsLexer(input_stream)
            stream = CommonTokenStream(lexer)
            parser = HotThreadsParser(stream)
            dump = parser.dump()
            for thread_idx in range(context_list_length(dump.threadDump)):
                thread_dump = dump.threadDump(thread_idx)
                thread_header = thread_dump.threadHeader()
                if self._above_threshold(thread_header):
                    # Store header only if beyond threshold cpu usage
                    thread_name = thread_header.name.getText()
                    if thread_name not in self._hot_thread_headers:
                        self._hot_thread_headers[thread_name] = []
                    self._hot_thread_headers[thread_name].append(thread_header)

    ## Returns whether the thread_header's CPU usage is atleast self.min_cpu
    def _above_threshold(self, thread_header):
        return self._get_header_usage(thread_header) >= self.min_cpu

    @staticmethod
    def _get_header_usage(thread_header):
        percentage_str = thread_header.Percentage().getText()
        return float(percentage_str.strip('%'))

    def _parse_jstack_dump(self):
        input_stream = FileStream(self._jstack)
        lexer = JStackDumpLexer(input_stream)
        stream = CommonTokenStream(lexer)
        parser = JStackDumpParser(stream)
        dump = parser.dump()

        for thread_idx in range(context_list_length(dump.threadDump)):
            thread_dump = dump.threadDump(thread_idx)
            thread_name = thread_dump.threadHeader().name.text
            if thread_name in self._hot_thread_headers:
                self._threads_stack[thread_name] = thread_dump

    def print_output(self):
        self.sort_stacks()
        for thread_name in self._hot_thread_names:
            for thread_header in self._hot_thread_headers[thread_name]:
                print(thread_header.getText())
            print(self._threads_stack[thread_name].getText())
            print("-------------------------------------------------")

    def sort_stacks(self):
        for thread_name in self._hot_thread_headers:
            self._hot_thread_headers[thread_name].sort(key=self._get_header_usage, reverse=True)

        self._hot_thread_names = list(self._hot_thread_headers.keys())
        self._hot_thread_names.sort(key=self._sorting_key, reverse=True)
        self._hot_thread_names = self._hot_thread_names[:self.top_stacks]

    def _sorting_key(self, thread_name):
        return sum([self._get_header_usage(header) for header in self._hot_thread_headers[thread_name]])


def main(argv):
    argparser = argparse.ArgumentParser(
        description='Filter jstack dump by ES thread names found in /_nodes/hot_threads outputs')
    argparser.add_argument('--jstack', required=True, help='jstack dump file')
    argparser.add_argument('--hot-threads', nargs='+', required=True, help='List of hot_threads output files')
    argparser.add_argument('--top-threads', type=int, default=3, help='Number of top stacks to print')
    argparser.add_argument('--min-cpu', type=float, default=0, help='Consider only the stacks with minimum cpu usage %')

    args = argparser.parse_args()
    hot_threads_jstack = HotThreadsJStack(args.hot_threads, args.jstack, args.top_threads, args.min_cpu)
    hot_threads_jstack.print_output()


if __name__ == '__main__':
    main(sys.argv)
